SECTION .text
GLOBAL _start
_start:
PUSH INT
CALL LERINTEIRO
PUSH DWORD [INT]
CALL ESCREVERINTEIRO
PUSH CHAR
CALL LERCHAR
PUSH DWORD [CHAR]
CALL ESCREVERCHAR
PUSH STRING
PUSH 10
CALL LERSTRING
PUSH STRING
PUSH 10
CALL ESCREVERSTRING
PUSH HEX
CALL LERHEXA
PUSH DWORD [HEX]
CALL ESCREVERHEXA
MOV EAX,1
MOV EBX,0
INT 0X80
LERINTEIRO:
;RECEIVE INTEGER (ASCII STRING) INPUT
    PUSH EBP        ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;DONT PUSH EAX BECAUSE EAX IS THE RETURN VALUE
    PUSH ECX    ;COUNTER OF ELEMENTS
    PUSH EDX    ;POINTER FOR CHAR STRING
    PUSH ESI    ;FLAG FOR NEGATIVE

    PUSH DWORD 0    ;RESERVE SPACE TO USE AS BUFFER
    PUSH DWORD 0
    PUSH DWORD 0
    ;ASK FOR INPUT

    PUSH EDI
    PUSH WORD 0 ;RESERVE BUFFER TO READ THE EXTRA CHARS
    MOV ECX, ESP    ;MOVE THE BUFFER TO ECX
    SUB ESI, ESI    ;RESET COUNTER
    MOV EDI, ESP ;POINTER TO STRING
    ADD EDI, 18

    GET_INPUT_CHARBYCHAR_INTEGER:
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV EDX, 1
    INT 0X80
    CMP BYTE [ECX], 0X0A    ;CHECK IF CHAR IS ENTER
    JE FINISH_INPUT_INTEGER ;IF ENTER - FINISH INPUT
    MOV EAX, [ECX]  ;MOVE THE CHAR INTO THE STRING
    MOV BYTE [EDI + ESI], AL
    INC ESI ;INCREMENT CHAR COUNTER
    CMP ESI, 12  ;CHECK IF STRING IS FULL --> COUNTER == STRING SIZE
    JE CHECK_EXTRA_CHAR_ENTER_INTEGER   ;IF YES = STRING FULL BUT STILL NO ENTER, READ AND TRASH NEXT CHARS UNTIL ENTER
    JMP GET_INPUT_CHARBYCHAR_INTEGER    ;KEEP GETTING INPUT

    CHECK_EXTRA_CHAR_ENTER_INTEGER: ;READ CHAR AND THROW IT AWAY UNTIL ENTER
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV EDX, 1
    INT 0X80
    CMP BYTE [ECX], 0X0A    ;CHECK IF CHAR IS ENTER
    JNE CHECK_EXTRA_CHAR_ENTER_INTEGER

    FINISH_INPUT_INTEGER:   ;FINISH GETTING INPUTS

    ADD ESP, 2  ;REMOVE BUFFER
    POP EDI ;POPS EDI BACK



    SUB EAX, EAX ;RESET THE ACCUMULATOR TO ZERO
    MOV EDX, ESP   ;PUT ADDRESS IN EDX
    ADD EDX, 12
    PUSH DWORD 10 ;STACK THE VALUE 10 TO MULTIPLY
    SUB ESI, ESI  ;ZERO THE NEGATIVE NUMBER FLAG
    SUB ECX, ECX ; ZERO THE COUNTER


CONVERT_CHARINT:
    CMP ECX, 11 ;AVOIDS ACESSING AN EXTRA ELEMENT
    JE FINISH_CHARINT
    MOVZX EBX, BYTE [EDX] ;GET CHAR
    INC EDX ;PREPARE NEXT CHAR
    INC ECX ;INCREMENT COUNTER
    CMP EBX, '-' ;CHECK FOR NEGATIVE
    JE NEGATIVE_CHARINT ;SET NEGATIVE FLAG

    CMP EBX, '0'    ;CHECK IF INTEGER
    JB FINISH_CHARINT
    CMP EBX, '9'    ;CHECK IF INTEGER
    JA FINISH_CHARINT
    SUB EBX, '0' ;CONVERT TO INTEGER
    PUSH EDX    ;SAVE EDX BEFORE ULTIPLICATION
    IMUL DWORD [ESP+4] ;MULTIPLY EAX BY 10 = GET READY FOR NEXT DIGIT
    POP EDX ;NO USE FOR EDX, MAXIMUM VALUE OF MULTIPLICATION FITS EAX
    ADD EAX, EBX    ;ADDS TOACUMULATOR VALUE
    JMP CONVERT_CHARINT ;JUMP UNTIL FINISHED
NEGATIVE_CHARINT:
    MOV ESI, 1  ;ESI IS A FLAG OR NEGATIVE
    JMP CONVERT_CHARINT

FINISH_CHARINT:
    DEC ECX ; COUNTER WILL HAVE 1 EXTRA FROM THE ENDING CHAR
    ADD ESP, 16  ;REMOVE 10 AND BUFFER FROM TOP OF STACK
    CMP ESI, 1 ;CHECK IF NEGATIVE
    JNE FINISH_AFTER_CHECK_CHARINT  ;IF NOT NEGATIVE, GO ON TO FINISH
    IMUL EAX, -1    ;IF NEGATIVE, MULTIPLY BY -1
FINISH_AFTER_CHECK_CHARINT:
    MOV EDX, [EBP + 8]
    MOV [EDX], EAX   ;NO ARGUMENTS - RETURN VALUE IS EBP + 8 BYTES PUSHED BY CALL AND FRAME CREATION (RETURN AND EBP)
    MOV EAX, ECX    ;MOVE COUNTER INTO EAX - NUMBER OF CHARACTERS INPUT

    POP ESI ;POPS ORIGINAL VALUE OF: ESI
    POP EDX ; -EDX
    POP ECX ; -ECX
    POP EBX ; -EBX

    POP EBP ;REMOVING STACK FRAME
    RET


ESCREVERINTEIRO:
;PRINT INTEGER (ASCII STRING) OUTPUT
    PUSH EBP    ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;DONT PUSH EAX BECAUSE EAX IS THE RETURN VALUE
    PUSH ECX    ;DIGIT COUNTER
    PUSH EDX    ;REST OF DIVISION - NUMBER TO CONVERT
    PUSH ESI    ;FLAG FOR NEGATIVE

    PUSH DWORD 0    ;RESERVE SPACE TO USE AS BUFFER
    PUSH DWORD 0
    PUSH DWORD 0



    MOV EAX, [EBP + 8]   ;NUMBER - PASSED AS ARGUMENT THROUGH STACK
    MOV EBX, ESP   ;STRING
    ADD EBX, 12
    MOV ECX, 0  ;DIGIT COUNTER
    PUSH DWORD 10 ;STACK THE VALUE 10 TO DIVIDE

CHECK_NEGATIVE:
    SUB ESI, ESI    ;SET NEGATIVE FLAG TO ZERO
    CMP EAX, 0  ;CHECK IF NUMBER IS SMALLER THEN 0
    JGE CONVERT_INTCHAR ;JUMP IF NUMBER IS POSITIVE
    MOV EDX, -1 ;PUT -1 ON EDX FOR MULTIPLICATION
    IMUL EDX     ;IF NEGATIVE MULTIPLY NUMBER BY -1 TO OPERATE ON UNSIGNED NUMBER
    MOV ESI, 1 ; ESI IS A NEGATIVE FLAG
CONVERT_INTCHAR:
    SUB EDX, EDX    ;ZERO EDX (REST OF DIVISION - NUMBER TO CONVERT)
    IDIV DWORD [ESP + ECX * 2] ;DIVIDE BY 10
    ADD EDX, '0'    ;CONVERT DIGIT TO ASCII CHAR
    PUSH DX ;STACK NUMBER CONVERTED TO ASCII - STACK WORKS WITH A MINIMUM 16 BITS
    INC ECX ;COUNT NUMBER OF DIGITS CONVERTED
    CMP EAX, 0  ;CHECK IF EAX IS 0 OR IF THERE IS STILL STUFF TO DIVIDE
    JNE CONVERT_INTCHAR ;JUMPS WHILE NOT FINISHED



OUTPUT_INTCHAR:
    MOV EAX, 0  ;RESET EAX TO USE IT AS COUNTER OF CHARS ADDED TO STRING
    CMP ESI, 0  ;CHECK IF NEGATIVE
    JE UNSTACK_RESULT_INTEGER   ;IF POSITIVE, JUMPS
    MOV BYTE [EBX + EAX], '-'   ;ADDS '-' TO START OF STRING
    INC EAX ;INCREMENT EAX - COUNTER OF CHARS ADDED TO STRING
    INC ECX ;INCREMENT ECX - COUNTER OF DIGITS CONVERTED - + THE NEGATIVE CHAR
    UNSTACK_RESULT_INTEGER:
    POP DX  ;POPS THE CHARS CONVERTED TO GET THE RIGHT ORDER
    MOV [EBX + EAX], DL ;MOVES THE ACTUAL BYTE OF THE CHAR TO THE STRING BUFFER AND IGNORES THE EMPTY DH
    INC EAX ;INCREMENTS EAX - COUNTER OF CHARS UNSTACKED
    CMP EAX, ECX    ;CHECK WITH ECX IF FINISHED UNSTACKING ALL CHARS
    JNE UNSTACK_RESULT_INTEGER  ;JUMP IF NOT FINISHED
    CMP ESI, 0  ;CHECKS IF NEGATIVE AGAIN
    SUB EDX, EDX    ;RESETS EDX
    JE FINISH_AFTER_CHECK_INTCHAR   ;JUMPS IF POSITIVE
    INC EDX ;EDX WILL HAVE 1 MORE BYTE TO PRINT, IN CASE OF NEGATIVE

    FINISH_AFTER_CHECK_INTCHAR:
    ADD ESP, 4 ;REMOVE THE VALUE 10FROM TOP OF STACK
PRINT_OUTPUT_INTEGER:
    ;OUTPUTS NUMBER
    PUSH ECX    ;SAVES ECX - DIGITS CONVERTED
    MOV EAX, 4
    MOV EBX, 1
    ADD EDX, ECX
    MOV ECX, ESP
    ADD ECX, 16 ;12 BYTES OF BUFFER AND 4 BYTES OF PUSHED ECX - GET TO THE START OF THE BUFFER
    INT 0X80

    ;OUTPUTS A LINEBREAK
    PUSH WORD 0X0D0A ;ADD LINEBREAK TO STACK
    MOV EAX, 4
    MOV EBX, 1
    MOV ECX, ESP
    MOV EDX, 2
    INT 0X80
    ADD ESP, 2 ;REMOVE LINEBREAK FROM STACK

    POP EAX ;MOVED ECX INTO EAX - DIGIT COUNTER
    ADD ESP, 12    ;REMOVE BUFFER FROM TOP OF STACK
    POP ESI ;UNSTACKING ORGIGINAL VALUES OF: -ESI
    POP EDX ;-EDX
    POP ECX ;-ECX
    POP EBX ;-EBX

    POP EBP ;REMOVED STACK FRAME
    RET 4 ;RETURNS AND REMOVES THE ARGUMENT RECEIVED FROM STACK


LERCHAR:
;RECEIVE ASCII CHAR INPUT
    PUSH EBP        ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;DONT PUSH EAX BECAUSE EAX IS THE RETURN VALUE
    PUSH ECX    ;COUNTER OF ELEMENTS - ALWAYS 1
    PUSH EDX    ;POINTER FOR CHAR STRING

    PUSH WORD 0 ;RESERVE SPACE FOR INPUT BUFFER
    ;ASK FOR INPUT
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV ECX, ESP
    ADD ECX, 2
    MOV EDX, 1
    INT 0X80

    MOV EAX, [ECX]  ;MOVING THE CHAR READ TO THE RETURN ADDRESS ON THE STACK
    MOV ECX, [EBP + 8]  ;||
    MOV [ECX], EAX  ; ||

    DEC ECX ;GET TO THE SECOND BYTE OF MEMORY ON THE BUFFER - USED TO READ UNTIL ENTER
    CHECK_EXTRA_CHAR_ENTER_CHAR:
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV EDX, 1
    INT 0X80
    CMP BYTE [ECX], 0X0A    ;CHECK IF CHAR IS ENTER
    JNE CHECK_EXTRA_CHAR_ENTER_CHAR

    MOV EAX, 1  ;EAX CONTAINS THE NUMBER OF ELEMENTS READ - ALWAYS 1 CHAR

    POP CX ; REMOVES THE BUFFER FROM TOP OF STACK

    POP EDX
    POP ECX
    POP EBX

    POP EBP ;REMOVE THE STACK FRAME

    RET


ESCREVERCHAR:
;PRINT ASCII CHAR OUTPUT
    PUSH EBP    ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;DONT PUSH EAX BECAUSE EAX IS THE RETURN VALUE
    PUSH ECX    ;DIGIT COUNTER
    PUSH EDX    ;REST OF DIVISION - NUMBER TO CONVERT


    MOV EAX, 4   ;INTERRUPTION
    MOV EBX, 1  ;STDOUT - MONITOR
    MOV ECX, EBP   ;CHAR TO PRINT - PASSED AS ARGUMENT THROUGH STACK
    ADD ECX, 8  ;||
    MOV EDX, 1 ;1 CHAR TO PRINT
    INT 0X80

    ;OUTPUTS A LINEBREAK
    PUSH WORD 0X0D0A ;ADD LINEBREAK TO STACK
    MOV EAX, 4
    MOV EBX, 1
    MOV ECX, ESP
    MOV EDX, 2
    INT 0X80
    ADD ESP, 2 ;REMOVE LINEBREAK FROM STACK

    MOV EAX, 1    ;NUMBER OF CHARS PRINTED - ALWAYS 1 CHAR
    POP EDX
    POP ECX
    POP EBX

    POP EBP ;REMOVE STACK FRAME

    RET 4   ;RETURN AND REMOVE ARGUMENT FROM STACK


LERSTRING:
;RECEIVE ASCII STRING INPUT
    PUSH EBP        ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;SIZE OF STRING
    PUSH ECX    ;POINTER FOR STRING AND COUNTER
    PUSH EDX    ;SIZE OF STRING AND STRING POINTER
    PUSH ESI    ;USED AS COUNTER TO GET INPUTS - CHAR BY CHAR
    PUSH EDI    ;USED AS POINTER TO STRING
    ;ASK FOR INPUT



    PUSH WORD 0 ;RESERVE BUFFER TO READ THE EXTRA CHARS
    MOV ECX, ESP    ;MOVE THE BUFFER TO ECX
    SUB ESI, ESI    ;RESET COUNTER
    MOV EDI, [EBP + 12] ;POINTER TO STRING

    GET_INPUT_CHARBYCHAR_STRING:
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV EDX, 1
    INT 0X80
    CMP BYTE [ECX], 0X0A    ;CHECK IF CHAR IS ENTER
    JE FINISH_INPUT_STRING ;IF ENTER - FINISH INPUT
    MOV BYTE AL, [ECX]  ;MOVE THE CHAR INTO THE STRING
    MOV BYTE [EDI + ESI], AL
    INC ESI ;INCREMENT CHAR COUNTER
    CMP ESI, [EBP + 8]  ;CHECK IF STRING IS FULL --> COUNTER == STRING SIZE
    JE CHECK_EXTRA_CHAR_ENTER_STRING   ;IF YES = STRING FULL BUT STILL NO ENTER, READ AND TRASH NEXT CHARS UNTIL ENTER
    JMP GET_INPUT_CHARBYCHAR_STRING    ;KEEP GETTING INPUT

    CHECK_EXTRA_CHAR_ENTER_STRING: ;READ CHAR AND THROW IT AWAY UNTIL ENTER
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV EDX, 1
    INT 0X80
    CMP BYTE [ECX], 0X0A    ;CHECK IF CHAR IS ENTER
    JNE CHECK_EXTRA_CHAR_ENTER_STRING

    FINISH_INPUT_STRING:   ;FINISH FETTING INPUTS

    ADD ESP, 2  ;REMOVE BUFFER
    POP EDI ;POPS EDI BACK
    POP ESI ;POPS ESI BACK


    MOV EDX, [EBP + 12] ; MOVE THE STRING POINTER TO EDX
    MOV ECX, 0  ;RESET COUNTER
    MOV EBX, [EBP + 8]  ;MOVE THE STRING SIZE TO EBX - AVOID SEGFAULT IF STRING IS MAX SIZE AND HAS NO ENTER
    DEC EBX ; DEC STRING SIZE TO GET THE LAST ELEMENT INDEX - NEEDED TO COMPARE WITH COUNTER (FROM 1->X TO 0->X-1)
    COUNT_INPUT:
    CMP BYTE [EDX], 0X0A    ;CHECK IF CHAR IS ENTER
    JE ENDCOUNT_INPUT ;IF YES, END COUNTING LOOP
    INC ECX ;INCREMENT COUNTER
    CMP ECX, EBX    ;CHECK IF COUNTER IS AT THE END OF THE STRING
    JE ENDCOUNT_INPUT ;IF YES, END COUNTING LOOP
    INC EDX ;GET NEXT CHAR
    JMP COUNT_INPUT   ;KEEP COUNTING
    ENDCOUNT_INPUT:
    MOV EAX, ECX    ;MOVE COUNTER TO EAX - RETURN THE NUMBER OF CHARS READ

    POP EDX
    POP ECX
    POP EBX

    POP EBP ;REMOVING STACK FRAME
    RET 8   ;RETURN AND REMOVE 2 ARGUMENTS FROM STACK


ESCREVERSTRING:
;PRINT INTEGER (ASCII STRING) OUTPUT
    PUSH EBP    ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;DONT PUSH EAX BECAUSE EAX IS THE RETURN VALUE
    PUSH ECX    ;POINTER FOR STRING AND COUNTER
    PUSH EDX    ;SIZE OF STRING AND POINTER TO STRING

    MOV ECX, 0  ;RESET COUNTER
    MOV EDX, [EBP + 12] ;POINTER TO STRING MOVED INTO EDX
    MOV EBX, [EBP + 8]  ;STRING SIZE

    COUNT_OUTPUT:
    CMP BYTE [EDX], 0X0A    ;CHECK IF CHAR IS ENTER
    JE ENDCOUNT_OUTPUT ;IF YES, END COUNTING LOOP
    INC ECX ;INCREMENT COUNTER
    CMP ECX, EBX    ;CHECK IF COUNTER IS AT THE END OF THE STRING
    JE ENDCOUNT_OUTPUT ;IF YES, END COUNTING LOOP
    INC EDX ;GET NEXT CHAR
    JMP COUNT_OUTPUT   ;KEEP COUNTING
    ENDCOUNT_OUTPUT:
    PUSH ECX    ;STORE THE NUMBER OF CHARS IN THE STRING

    MOV EAX, 4
    MOV EBX, 1  ;1 = STDOUT - MONITOR
    MOV EDX, ECX
    MOV ECX, [EBP + 12]
    INT 0X80

    ;OUTPUTS A LINEBREAK
    PUSH WORD 0X0D0A ;ADD LINEBREAK TO STACK
    MOV EAX, 4
    MOV EBX, 1
    MOV ECX, ESP
    MOV EDX, 2
    INT 0X80
    ADD ESP, 2 ;REMOVE LINEBREAK FROM STACK

    POP EAX ;MOVED ECX INTO EAX - CHAR COUNTER
    POP EDX
    POP ECX
    POP EBX

    POP EBP ;REMOVED STACK FRAME
    RET 8 ;RETURNS AND REMOVES THE ARGUMENTS RECEIVED FROM STACK

LERHEXA:
;RECEIVE INTEGER (ASCII STRING) INPUT IN HEX
    PUSH EBP        ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;DONT PUSH EAX BECAUSE EAX IS THE RETURN VALUE
    PUSH ECX    ;COUNTER OF ELEMENTS
    PUSH EDX    ;POINTER FOR CHAR STRING

    PUSH DWORD 0  ;RESERVE SPACE (8 BYTES) TO USE AS BUFFER
    PUSH DWORD 0

    PUSH EDI
    PUSH WORD 0 ;RESERVE BUFFER TO READ THE EXTRA CHARS
    MOV ECX, ESP    ;MOVE THE BUFFER TO ECX
    SUB ESI, ESI    ;RESET COUNTER
    MOV EDI, ESP ;POINTER TO STRING
    ADD EDI, 14

    ;ASK FOR INPUT
    GET_INPUT_CHARBYCHAR_HEX:
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV EDX, 1
    INT 0X80
    CMP BYTE [ECX], 0X0A    ;CHECK IF CHAR IS ENTER
    JE FINISH_INPUT_HEX ;IF ENTER - FINISH INPUT
    MOV EAX, [ECX]  ;MOVE THE CHAR INTO THE STRING
    MOV BYTE [EDI + ESI], AL
    INC ESI ;INCREMENT CHAR COUNTER
    CMP ESI, 8  ;CHECK IF STRING IS FULL --> COUNTER == STRING SIZE
    JE CHECK_EXTRA_CHAR_ENTER_HEX   ;IF YES = STRING FULL BUT STILL NO ENTER, READ AND TRASH NEXT CHARS UNTIL ENTER
    JMP GET_INPUT_CHARBYCHAR_HEX    ;KEEP GETTING INPUT

    CHECK_EXTRA_CHAR_ENTER_HEX: ;READ CHAR AND THROW IT AWAY UNTIL ENTER
    MOV EAX, 3
    MOV EBX, 0  ;0 = STDIN - TECLADO
    MOV EDX, 1
    INT 0X80
    CMP BYTE [ECX], 0X0A    ;CHECK IF CHAR IS ENTER
    JNE CHECK_EXTRA_CHAR_ENTER_HEX

    FINISH_INPUT_HEX:   ;FINISH GETTING INPUTS

    ADD ESP, 2  ;REMOVE BUFFER
    POP EDI ;POPS EDI BACK



    SUB EAX, EAX ;RESET THE ACCUMULATOR TO ZERO
    MOV EDX, ESP   ;PUT ADDRESS IN EDX
    ADD EDX, 8
    PUSH DWORD 16 ;STACK THE VALUE 16 TO MULTIPLY
    SUB ECX, ECX ; ZERO THE COUNTER


CONVERT_CHARINT_HEX:
    CMP ECX, 8  ;AVOIDS ACESSING AN EXRA ELEMENT
    JE FINISH_CHARINT_HEX
    MOVZX EBX, BYTE [EDX] ;GET CHAR
    INC EDX ;PREPARE NEXT CHAR
    INC ECX ;INCREMENT COUNTER

    CMP EBX, '0'    ;CHECK IF NUMBER
    JB FINISH_CHARINT_HEX
    CMP EBX, '9'    ;CHECK IF NUMBER
    JBE CONVERT_CHAR_INT
    CMP EBX, 'A'    ;CHECK IF NUMBER AS HEX UPPER
    JB FINISH_CHARINT_HEX   ;ALREADY JUMPED IF BETWEEN 0-9
    CMP EBX, 'F'    ;CHECK IF NUMBER AS HEX UPPER
    JBE CONVERT_HEX_INT_UPPER
    CMP EBX, 'A'    ;CHECK IF NUMBER AS HEX LOWER
    JB FINISH_CHARINT_HEX
    CMP EBX, 'F'    ;CHECK IF UMBER AS HEX LOWER
    JBE CONVERT_HEX_INT_LOWER   ;ALREADY JUMPED IF OTHER CASES
    JMP FINISH_CHARINT_HEX  ;CHECKED EVERYTHING - NOT A VALID CHAR
    ;IF REORGANIZED, COULD HAVE SPARED ONE EXTRA JUMP, BUT THIS WAY THE CODE IS MORE READABLE
    ;THE "SWITCH" FOLLOWS THE SAME LOGIC AND PATTERN THROUGHOUT ITS CODE

    CONVERT_HEX_INT_UPPER:    ;IF DIGIT IS HEX CHAR - CONVERT TO DECIMAL VALUE
    SUB EBX, 'A'    ;CONVERT TO INTEGER NUMBER
    ADD EBX, 10
    JMP AFTER_CHECK_CHARINT_HEX
    CONVERT_HEX_INT_LOWER:
    SUB EBX, 'A'    ;CONVERT TO INTEGER NUMBER
    ADD EBX, 10
    JMP AFTER_CHECK_CHARINT_HEX

    CONVERT_CHAR_INT:   ;IF DIGIT IS DECIMAL CHAR - CONVERT TO DECIMAL VALUE
    SUB EBX, '0' ;CONVERT TO INTEGER NUMBER

    AFTER_CHECK_CHARINT_HEX:
    PUSH EDX    ;SAVE EDX BEFORE ULTIPLICATION
    IMUL DWORD [ESP+4] ;MULTIPLY EAX BY 16 = GET READY FOR NEXT DIGIT
    POP EDX ;NO USE FOR EDX, MAXIMUM VALUE OF MULTIPLICATION FITS EAX
    ADD EAX, EBX    ;ADDS TO ACUMULATOR VALUE
    JMP CONVERT_CHARINT_HEX ;JUMP UNTIL FINISHED

FINISH_CHARINT_HEX:
    DEC ECX ; COUNTER WILL HAVE 1 EXTRA FROM THE ENDING CHAR
    ADD ESP, 12  ;REMOVE 16  AND BUFFER FROM TOP OF STACK
FINISH_AFTER_CHECK_CHARINT_HEX:
    MOV EDX, [EBP + 8]
    MOV[EDX], EAX   ;NO ARGUMENTS - RETURN VALUE IS EBP + 8 BYTES PUSHED BY CALL AND FRAME CREATION (RETURN AND EBP)
    MOV EAX, ECX    ;MOVE COUNTER INTO EAX - NUMBER OF CHARACTERS INPUT

    POP EDX
    POP ECX
    POP EBX

    POP EBP ;REMOVING STACK FRAME

    RET


ESCREVERHEXA:
;PRINT INTEGER (ASCII STRING) OUTPUT IN HEX
    PUSH EBP    ;CREATING STACK FRAME
    MOV EBP, ESP    ;CREATING STACK FRAME
    PUSH EBX    ;DONT PUSH EAX BECAUSE EAX IS THE RETURN VALUE
    PUSH ECX    ;DIGIT COUNTER
    PUSH EDX    ;REST OF DIVISION - NUMBER TO CONVERT

    PUSH DWORD 0    ;RESERVE SPACE TO USE AS BUFFER
    PUSH DWORD 0



    MOV EAX, [EBP + 8]   ;NUMBER - PASSED AS ARGUMENT THROUGH STACK
    MOV EBX, ESP   ;STRING
    ADD EBX, 8
    MOV ECX, 0  ;DIGIT COUNTER
    PUSH DWORD 16 ;STACK THE VALUE 16 TO DIVIDE

CONVERT_INTCHAR_HEX:
    MOV EDX, 0    ;ZERO EDX (REST OF DIVISION - NUMBER TO CONVERT)
    IDIV DWORD [ESP + ECX * 2] ;DIVIDE BY 16
    CMP EDX, 10
    JGE CONVERT_INT_HEX
    ADD EDX, '0'    ;CONVERT DIGIT TO ASCII CHAR
    JMP AFTER_CHECK_HEX
    CONVERT_INT_HEX:
    ADD EDX, 'A'
    SUB EDX, 10
    AFTER_CHECK_HEX:
    PUSH DX ;STACK NUMBER CONVERTED TO ASCII - STACK WORKS WITH A MINIMUM 16 BITS
    INC ECX ;COUNT NUMBER OF DIGITS CONVERTED
    CMP EAX, 0  ;CHECK IF EAX IS 0 OR IF THERE IS STILL STUFF TO DIVIDE
    JNE CONVERT_INTCHAR_HEX ;JUMPS WHILE NOT FINISHED



OUTPUT_INTCHAR_HEX:
    UNSTACK_RESULT_HEX:
    POP DX  ;POPS THE CHARS CONVERTED TO GET THE RIGHT ORDER
    MOV [EBX + EAX], DL ;MOVES THE ACTUAL BYTE OF THE CHAR TO THE STRING BUFFER AND IGNORES THE EMPTY DH
    INC EAX ;INCREMENTS EAX - COUNTER OF CHARS UNSTACKED
    CMP EAX, ECX    ;CHECK WITH ECX IF FINISHED UNSTACKING ALL CHARS
    JNE UNSTACK_RESULT_HEX  ;JUMP IF NOT FINISHED
    CMP ESI, 0  ;CHECKS IF NEGATIVE AGAIN
    SUB EDX, EDX    ;RESETS EDX
    JE FINISH_AFTER_CHECK_INTCHAR_HEX   ;JUMPS IF POSITIVE
    INC EDX ;EDX WILL HAVE 1 MORE BYTE TO PRINT, IN CASE OF NEGATIVE

    FINISH_AFTER_CHECK_INTCHAR_HEX:
    ADD ESP, 4 ;REMOVE THE VALUE 16 FROM TOP OF STACK
PRINT_OUTPUT_HEX:
    ;OUTPUTS NUMBER
    PUSH ECX    ;SAVES ECX - DIGITS CONVERTED
    MOV EAX, 4
    MOV EBX, 1
    ADD EDX, ECX
    MOV ECX, ESP
    ADD ECX, 12 ;12 BYTES OF BUFFER AND 4 BYTES OF PUSHED ECX - GET TO THE START OF THE BUFFER
    INT 0X80

    ;OUTPUTS A LINEBREAK
    PUSH WORD 0X0D0A;ADD LINEBREAK TO STACK
    MOV EAX, 4
    MOV EBX, 1
    MOV ECX, ESP
    MOV EDX, 2
    INT 0X80
    ADD ESP, 2 ;REMOVE LINEBREAK FROM STACK

    POP EAX ;MOVED ECX INTO EAX - DIGIT COUNTER
    ADD ESP, 8    ;REMOVE BUFFER FROM TOP OF STACK

    POP EDX ;-EDX
    POP ECX ;-ECX
    POP EBX ;-EBX

    POP EBP ;REMOVED STACK FRAME
    RET 4 ;RETURNS AND REMOVES THE ARGUMENT RECEIVED FROM STACK
SECTION .data
INT: dd 0
CHAR: dd 0
STRING: dd 0
HEX: dd 0
